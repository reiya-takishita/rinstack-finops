
# FinOps機能基本設計書（全体）Ver27

---

## Part A. Overview & Scope（概要・スコープ・前提）

### 0. 本書の確定範囲と未確定範囲（Scope Definition）

本書（FinOps 基本設計書）は以下を「確定事項」とする。

#### ✔ 確定事項（Basic Design Confirmed）

- 初期スコープでは **クラウドプロバイダー ロール引き受け方式** による接続方式を採用する（抽象モデルはクラウド横断）
- FinOps 機能の全体アーキテクチャ（コンテナ境界・連携方式）
- データモデルの概念構造（解析履歴・提案セット・改善提案・適用履歴）
- クラウドプロバイダー 接続方式（ロール引き受け方式 ベース）
- UI 3 画面の情報構造（Figma）
- FinOps の責務範囲と Rinstack 本体との境界
- 課金レポート 取得 → 集計 → LLM 解析 → 履歴保存の処理フロー
- API の抽象仕様（I/O の概念定義）

#### 🔧 未確定事項（To Be Defined in Detail Design）

以下は詳細設計フェーズで確定する。

- クラウドプロバイダー クラウド側の認可ロール の権限範囲・信頼ポリシー
- 課金レポート パースロジック（CSV / Parquet / Athena）
- DB 製品選定（RDB / NoSQL）
- インデックス定義・キー設計
- LLM モデル選定・プロンプトテンプレート
- KPI / コスト予測ロジック
- API の完全スキーマ
- バッチ実行方針（オンデ / スケジュール）と同時実行制御
- Terraform 連携のインターフェース仕様
- 改善案ステータス遷移の厳密定義

本章は本書の適用範囲を正確に理解するためのものであり、  
詳細設計フェーズの誤読・過剰実装・仕様逸脱を防止することを目的とする。

---

### 0. 文書情報

- 文書名：FinOps機能基本設計書（全体）
- 版数：27.0.0
- 想定読者：
  - システムアーキテクト
  - バックエンドエンジニア
  - FinOps 機能の詳細設計・実装を行うエンジニア（人間／LLM を問わない）
- 対象システム：
  - Rinstack 本体（`rinstack-app` / `rinstack-web`）
  - FinOps サービス（新規コンテナ）
- 対象クラウド：クラウド環境（将来マルチクラウド対応を検討）

---

## 1. 目的

本書は Rinstack に新規追加する **FinOps（クラウドコスト最適化）機能** について、

- システム構成（コンテナ境界・連携方式）
- クラウドプロバイダーとの連携方式（ロールフェデレーション方式の概要）
- 処理構成（課金レポート取得／解析実行トリガー／LLM 解析）
- データモデル（コスト集計・ダッシュボード KPI・解析履歴・適用履歴）
- 抽象レベルの API 仕様
- Terraform / GitHub 連携との責務境界

を定義する **FinOps 全体の基本設計書** である。

本書は 詳細設計・実装を他のエンジニアや LLM が行う際の「コンテキストの鏡」として機能することを目的とし、  
テーブルカラム名・API パラメータなどは日本語で概念を明示したうえで、命名の自由度を一定程度残す。

---

## 2. FinOps 機能のスコープ

### 2.1 行うこと（FinOps 全体スコープ）

本書が対象とする FinOps 機能は、Rinstack プロダクトにおける FinOps の「全体像」を扱う。  
具体的には、以下を含む。

ユーザーが既に保有している クラウドプロバイダー 環境に対して：

- クラウドプロバイダー 課金レポート（Cost & Usage Report）をストレージから取得
- コストをプロジェクト単位で集計
- ダッシュボード画面（Figma：コスト運用画面）向けに KPI・グラフ用データを提供
- LLM によるコスト最適化提案（改善案）を生成・保存
- 「解析履歴」として、各分析実行ごとの状態を保持
- 「適用履歴」として、どの改善提案をどの Terraform バージョンに適用したかの履歴を保持
- 将来的に Terraform への反映や GitHub PR 生成の基礎となる構造化情報を提供

FinOps のデータは **Rinstack プロジェクト単位** で管理する。

### 2.2 行わないこと（非スコープ）

本書では、以下は FinOps 機能の外側の責務として扱う。

- Terraform の解析（HCL の読み取り・差分計算）
- GitHub リポジトリとの連携・Pull Request 作成
- 改善案の自動適用（インフラ構成の変更そのもの）
- UI の詳細な遷移仕様（どの画面からどの画面へ遷移するか）
- マルチクラウド（クラウドプロバイダー / クラウドプロバイダー / クラウドプロバイダー 等）の実装（将来拡張）
- 個別リリーススプリントにおける「今回の開発スコープ」などの時期依存の制約

Terraform への反映は、Rinstack 本体の IaC 機能側で扱う別スコープとする。  
本書は、あくまで **FinOps 機能全体の概念と構造** を定義する。

---

## Part B. Architecture & Processing（アーキテクチャと処理フロー）

## 3. システム構成・境界

### 3.1 コンテナ構成

**Rinstack 本体コンテナ**

- ユーザー認証・組織／プロジェクト管理
- JWT 発行（ユーザー JWT / サービス JWT）
- Terraform 管理・生成
- GitHub 連携

**FinOps コンテナ（新規）**

- REST API（FinOps 専用）
- 課金レポート取得および解析を行う処理（バッチ／オンデマンド）
- LLM 解析処理
- FinOps 専用 DB（RDB / NoSQL は後述。以降「FinOps DB」と呼ぶ）

FinOps コンテナは、`rinstack-app` とは論理的に分離されたコンテナとして動作し、  
service-to-service JWT を介して Rinstack 本体と連携する。

### 3.2 連携方式

**FinOps → Rinstack 本体：**

- service-to-service JWT（既存 `service-auth.middleware` を利用）
- `client_id = "finops-service"`（想定）

**Rinstack 本体 → FinOps：**

- REST API 呼び出し
- `organizationId`, `projectId` をパラメータとして付与

FinOps 側は ユーザー認証・認可ロジックを持たず、  
「どの組織・プロジェクトのデータか」を識別する ID を受け取り、自身の DB に保存・参照するのみとする。

### 3.3 Terraform / GitHub との関係

Rinstack 本体は Terraform のバージョン管理と GitHub 連携の責務を持つ。

FinOps は、LLM 改善案や適用履歴を通じて  
「どの Terraform バージョンに対して、どの改善案を適用したか」を表現する。

Terraform の具体的な差分生成／PR 作成は本書のスコープ外だが、  
FinOps 側のモデルは **将来これを実現できるように構造化** される。

---

## 4. クラウド接続方式（ロールフェデレーション方式：抽象モデル）

### 4.1 接続方式の基本概念

外部アプリケーションへ一時的に権限を委譲する「ロールフェデレーション方式」を、  
クラウド横断の抽象モデルとして採用する。

### 4.2 クラウド別フェデレーション方式（名称のみ）

- クラウドプロバイダー：ロール引き受け方式 相当
- クラウドプロバイダー：Workload Identity Federation
- クラウドプロバイダー：Federated Credential
- クラウドプロバイダー：Dynamic Group ベース
- クラウドプロバイダー：固定鍵方式寄り（将来拡張余地あり）

### 4.3 `CloudConnectionConfig`（抽象モデル）

```json
{
  "provider": "aws | gcp | azure | oci | sakura",
  "federation": {
    "type": "federated | apikey",
    "metadata": {}
  },
  "billingSource": {
    "type": "objectStorage | bigquery | ...",
    "location": "..."
  }
}
```

### 4.4 UI 抽象項目

- クラウドプロバイダの選択
- フェデレーション関連の抽象フィールド
- 請求データ（Billing Export）の位置を示す抽象フィールド

---

## 5. 処理構成（バッチ／オンデマンド）

FinOps のコア処理は以下で構成される：

1. 課金レポートファイル取得
2. 解析実行トリガー（バッチ／オンデマンド）
3. LLM 解析（改善案生成）
4. 解析履歴の保存
5. 改善案の保存
6. 適用履歴の更新

### 5.1 課金レポートファイル取得処理（課金レポート取得）

**目的：**  
ストレージ上の課金レポートファイルを列挙し、処理対象として管理する。

**入力：**

- プロジェクトごとの クラウドプロバイダー 接続設定

**処理：**

1. 対象プロジェクトの課金レポートが配置されるストレージのパスを取得
2. ストレージ上の課金レポートファイル一覧を取得
3. まだ処理していないファイルのみを「課金レポートファイル管理」コレクションに登録  
   - プロジェクト ID  
   - ファイル名  
   - ストレージ キー  
   - ステータス（未処理）  
   - 課金レポート期間（例：2025-11）

**備考：**

- プロジェクト単位で順次実行
- 大量ファイル環境でもロック／デッドロックが発生しないよう、処理並列度は制御する

### 5.2 解析実行のトリガー方式

解析（課金レポート → 集計 → LLM 提案）は、以下二つの方式が候補となる。

#### (A) バッチ方式

- 日次／週次などで自動実行

**メリット：**

- ユーザー操作なしで最新状態を維持できる

**デメリット：**

- 解析履歴が増え続け、どのタイミングの提案かが分かりにくくなる

#### (B) オンデマンド方式（UI トリガー）

- ユーザーが画面から「コスト改善を解析する」操作を行ったタイミングで実行

**メリット：**

- ユーザーが意図したタイミングで解析履歴を作成できる
- 解析結果と Terraform バージョンとの対応付けがしやすい

**デメリット：**

- ユーザー操作が必要

本書では、解析トリガーは **(B) オンデマンド方式を主** とする前提とする。  
(A) バッチ方式は、将来の運用要件に応じて採用可否を判断する選択肢として残す。

### 5.3 LLM 解析処理（解析バッチ／オンデマンド共通）

**目的：**  
課金レポート集計結果からコスト改善案を生成し、解析履歴・改善案として保存する。

**入力：**

- プロジェクト ID
- 対象とする課金レポート期間（例：2025-11）
- 必要に応じて現在の Terraform バージョン情報（例：`tf_v3`）

**処理：**

1. 「課金レポートファイル管理」から対象期間のファイルを特定
2. 課金レポートファイルを読み込み、明細レコードを解析
3. コスト集計（コスト集計モデルに基づく）
   - サービス別 × 月別の集計
   - プロジェクトの月次合計
   - 前月同時期の合計
4. 集計結果から LLM へプロンプトを構築
5. LLM から **改善提案セット（複数件の提案）** を取得
6. 解析履歴（`AnalysisHistory`）として保存
7. 改善案セットおよび個別改善案として保存

LLM の役割は、「集計済みデータからの説明・改善案生成」に限定し、  
課金レポートのパースや数値集計は FinOps サービス側の決定的ロジックとする。

---

## 12. バッチ処理とオンライン処理の分界

課金レポート取得はバッチ／オンデマンドのいずれも可能だが、MVP ではオンデマンド解析を主とする。

オンライン画面（ダッシュボード）は、**最新の解析履歴に紐づく集計結果** を表示するのが基本である。

解析結果が存在しない場合の振る舞い（例：空表示／課金レポートからの自動集計）は、  
UX と相談の上、詳細設計で決定する。

---

## 19. バッチ処理とユーザートリガー実行に関する前提

### 19.1 日次バッチのみとした場合の課題

課金レポート → LLM 解析を日次バッチ等で自動実行する場合、以下の課題がある。

- 毎日解析履歴が生成され、履歴数が増え続ける
- どの解析に基づく提案を採用したのかが分かりにくい
- Terraform バージョンとの対応が複雑化する

### 19.2 ユーザートリガー実行の前提

ユーザーが UI から「今このタイミングでコスト改善を解析したい」と考えるケースがある。

この場合、「解析履歴」と「適用履歴」はユーザーの意図したタイミングに結びつくため、  
IaC バージョン管理との整合性が取りやすい。

### 19.3 実行方式の扱い

本書では、解析の実行方式を「バッチ方式」「オンデマンド方式」の両方を許容する。

ただし、解析履歴と適用履歴のモデルはどちらの方式を採用しても破綻しないよう設計されている。

実際にどの方式を採用するかは、運用要件・コスト・UX を踏まえて詳細設計で決定する。

---

## Part C. Data Model & DB（データモデルと DB 前提）

## 6. データモデル（概念設計）

FinOps DB には、以下の概念コレクション（またはテーブル）を持つ。

### 6.1 クラウドプロバイダー 接続設定

**用途：**  
各プロジェクトがどのクラウドプロバイダー環境に対して課金レポートを取得するかを管理する。

- 組織 ID
- プロジェクト ID
- 接続方式（ロール引き受け方式 固定、将来 AccessKey 等の拡張もあり得る）
- クラウドプロバイダー アカウント ID
- 課金レポートが配置されるストレージ名
- ストレージ プレフィックス
- 認証情報（暗号化済みの資格情報一式）
- 登録日時
- 更新日時

### 6.2 課金レポートファイル管理

**用途：**  
課金レポートファイルごとの処理状態を管理する。

- 課金レポートファイル ID
- プロジェクト ID
- ファイル名
- ストレージ キー（パス）
- ステータス（未処理／処理中／完了／失敗）
- エラー内容（失敗時）
- 課金レポート 対象期間（例：2025-11）
- 登録日時
- 更新日時

### 6.3 コスト日次・月次集計（基礎集計）

Figma「コスト運用画面」で扱う KPI やグラフの元となる、日次・月次レベルの集計。

#### 6.3.1 日次コスト集計（必要に応じて）

- プロジェクト ID
- 日付
- 合計コスト（円）
- サービス別集計の参照（任意）

※ 前月同時期比較のため、日別合計を持っておくと処理が簡単になる。

#### 6.3.2 月次コスト集計

- プロジェクト ID
- 対象月（例：2025-11）
- 月間合計コスト（円）
- 当月予測コスト合計（円）
  - 「当月 1 日〜本日までの平均コスト × 月の日数」などのロジックは詳細設計で決定
- 前月同時期コスト（円）
  - 当月の「1日〜本日」と同じ日数分までを前月から算出
- 前月総コスト（円）

### 6.4 サービス別 × 月別コスト集計

Figma 1 枚目の以下要素を支えるデータ：

- 「サービスごとのコスト内訳」棒グラフ
- 「コスト履歴」テーブル（サービス行 × 月列）

**項目例：**

- プロジェクト ID
- 対象月（例：2025-11）
- サービス名（例：Amazon Simple Storage Service）
- 月間コスト（円）

この集計を元に：

- 月別縦棒グラフ（スタック）
- サービス別テーブル（4 月〜11 月列、合計列）

などの表示が可能となる。

### 6.5 ダッシュボード KPI モデル（コスト運用画面）

Figma 1 枚目（コスト運用画面）の上部 KPI カードに必要な項目を整理する。

#### 6.5.1 KPI 名と意味（暫定定義）

- **当月のコスト合計**  
  当月 1 日〜本日までの確定コスト合計

- **当月予測コスト合計**  
  当月末までの予測コスト  
  ロジック例：
  - 「当月 1 日〜本日までの平均コスト × 月の日数」

- **前月同時期のコスト**  
  前月 1 日〜本日と同じ日数分までのコスト合計

- **前月の総コスト**  
  前月 1 日〜末日までの総コスト

- **施策により削減したコスト合計**  
  実際に実行された最適化施策の結果として削減されたと見なす金額の合計  
  本書時点では、「施策実績に記録された削減額の合算」とする

- **実行した施策数**  
  実行済みとマークされた施策（改善案）の件数

- **最適化提案数**  
  LLM によって生成された改善案の件数（プロジェクト単位、期間条件は詳細設計で定義）

> ※ KPI の詳細な定義（どの期間の実績を対象とするか、複数の解析履歴が存在する場合にどれを採用するか）は、ビジネス要件に基づき別途確定させる必要がある。

#### 6.5.2 KPI データの持ち方

KPI の多くは「基礎集計・施策実績・解析履歴」の組み合わせから計算可能であるため、

- 専用の KPI コレクションを持つか
- API 呼び出し時に計算するか

は性能と実装コストを踏まえ、詳細設計で決定する。

### 6.6 解析履歴（AnalysisHistory）

**用途：**  
課金レポート解析結果および LLM 改善提案の「スナップショット」を保持する。

解析履歴は「どのタイミングで、どのデータ（課金レポート）を元に、どの改善提案セットが生成されたか」を表現する。

- 解析 ID（`analysis_id`）
- プロジェクト ID
- 解析名称（例：2025-11 コスト改善 v1）
- 解析実行日時
- 対象 課金レポート期間（例：2025-11）
- 解析対象の Terraform バージョン（例：`tf_v3`）※任意
- LLM モデル名（例：`gpt-5.1`）
- 解析ステータス（成功／失敗）
- 失敗時のエラー情報
- 関連する改善提案セット ID のリスト

解析履歴を持つことで、  
「どの時点の環境・コストに対してどのような提案が出ていたか」を後からトレースできる。

### 6.7 改善提案セット（ProposalSet）

**用途：**  
LLM から一度の解析でまとめて出力される「複数件の改善提案」の塊を表現する。

- 改善提案セット ID（`proposal_set_id`）
- プロジェクト ID
- 関連する解析 ID（`analysis_id`）
- 改善提案件数
- 生成日時
- 備考（例：LLM プロンプトのバージョン情報）

改善提案セットは、個々の改善案（次項）を束ねる上位概念であり、  
「この 10 件の提案は、同じ解析からまとめて生成された」という関係を保証する。

### 6.8 改善案（個別 LLM 提案）モデル

**用途：**  
LLM が生成した個別の「コスト削減のための提案」を保存し、一覧画面・詳細画面から参照する。

- 改善案 ID（`proposal_id`）
- 改善案コード（画面表示用：例「CSG000001」）
- プロジェクト ID
- 提案セット ID（`proposal_set_id`）
- 対応する解析 ID（`analysis_id`）
- タイトル（例：DB インスタンスタイプ見直し）
- 概要説明文（自然言語）
- 対象サービス名（例：マネージドデータベース, コンテナ実行環境）
- 対象リソース種別（例：`db.m5.large`）
- 重要度（高／中／低）
- ステータス（未対応／対応中／対応済み 等）
- 提案作成日時
- 最終更新日時
- 推定削減額（円）
- 現在構成情報（JSON）
  - インスタンスタイプ
  - vCPU
  - メモリ
  - 台数 など
- 推奨構成情報（JSON）
  - 推奨インスタンスタイプ
  - vCPU
  - メモリ
  - 予測台数 など
- 現在構成における月額／年額コスト
- 推奨構成における月額／年額コスト
- 削減可能額・削減率
- リスク評価情報（JSON）
  - 各リスク項目の名称
  - リスクレベル（高／中／低）
  - コメント（自然言語）

> LLM は、主に「説明文」「推奨構成の候補」「リスクコメント」を生成する役割とし、  
> コスト計算と削減額算出は FinOps サービス側の責任とする。

### 6.9 適用履歴（ApplyHistory）

**用途：**  
どの解析からどの改善提案を採用し、Terraform のどのバージョンに対してどのように適用されたかを記録する。

PM の意図（例：「10 件中 2 件を v1 の Terraform に適用して v2 を生成」「さらに 3 件を v2 に適用して v3 を生成」…）を表現できるようにする。

- 適用履歴 ID（`apply_id`）
- プロジェクト ID
- 関連する解析 ID（`analysis_id`）
- 関連する改善提案セット ID（`proposal_set_id`）
- 適用した改善案 ID のリスト（複数）
- 適用前の Terraform バージョン（例：`tf_v1`）
- 適用後の Terraform バージョン（例：`tf_v2`）
- 適用実行日時
- 実行者（ユーザー ID）
- 適用種別（手動／自動）
- 適用時点での削減見込み額（合計）
- 適用後に確認された実績削減額（あれば）

適用履歴を分離して持つことで、

- 同一解析から複数回に分けて提案を適用する
- 適用後の Terraform バージョンと紐づける
- 後から「どの提案を採用したか」を再確認する

といった利用が可能になる。

### 6.10 最適化施策実績モデルとの関係

「施策により削減したコスト合計」「実行した施策数」などの KPI 計算のため、  
適用履歴とは別に「施策実績」を持つ設計もあり得る。

- 施策実績 ID
- プロジェクト ID
- 関連する適用履歴 ID（`apply_id`）
- 実行日時
- 実績削減額
- 備考コメント

本書では、適用履歴モデルを優先的に設計対象とし、  
施策実績モデルは KPI 要件に応じて詳細設計で導入可否を決定する。

---

## 17. 解析履歴と適用履歴のデータモデル（追加項目）

本章は本書で整理した「解析履歴」と「適用履歴」、および Terraform バージョン遷移の概念モデルを示す。  
FinOps 機能を単発の解析結果ではなく、時間軸と IaC バージョンを伴う「履歴管理機能」として扱うための前提となる。

### 17.1 背景と目的

課金レポートから LLM によるコスト改善提案を生成する処理は、将来的に複数回実行されることを前提とする。

改善提案は 1 回の解析で複数件（例：10 件）生成され、その一部のみを段階的に Terraform に適用していくケースが想定される。

日次・週次バッチ等で「常に最新の解析を上書き」してしまうと、ユーザーから見て

- 「いつ」
- 「どの 課金レポート / Terraform 状態に対して」
- 「どの改善提案が生成され」
- 「そのうち何件をどの順番で適用したか」

が分からなくなる。

このため、解析単位の履歴（解析履歴）と、その解析に紐づく適用履歴を明示的に持つ必要がある。

### 17.2 概念モデルの全体像

FinOps の改善提案まわりの概念モデルは、以下のように整理する。

- プロジェクト
  - 解析履歴（`AnalysisHistory`） … 1:n
  - 改善提案セット（`ProposalSet`） … 1:1（解析ごとに 1 セット）
  - 適用履歴（`ApplyHistory`） … 1:n（解析ごとに複数回の適用）

このとき、Terraform のバージョンは解析履歴および適用履歴と論理的に関連付けられる。

### 17.3 解析履歴（AnalysisHistory）

**用途：**  
「どのタイミングで、どの状態の環境に対して FinOps 解析を実行したか」を表現する。

**主な項目（概念）：**

- 解析 ID（`analysisId`）
- プロジェクト ID
- 解析実行日時（`analysisAt`）
- 解析対象の 課金レポート 情報
  - 対象期間（例：2025-11）
  - 対象とした課金レポートファイルの一覧
- 解析対象の Terraform バージョン（例：`tf_v3`）
- LLM モデルバージョン（例：`gpt-5.1`）
- 提案セット ID（`proposalSetId`）
- 備考（例：解析時に使用した閾値・パラメータなど）

### 17.4 改善提案セット（ProposalSet）

**用途：**  
1 回の解析で LLM が生成した改善提案を、セットとして管理する。

**主な項目（概念）：**

- 提案セット ID（`proposalSetId`）
- 対応する解析 ID（`analysisId`）
- 提案件数（例：10 件）
- 各提案の一覧（Proposal エンティティへの参照）
  - 提案 ID（`proposalId`）
  - 対象サービス名
  - 対象リソース種別

既存の「改善案（LLM 提案）モデル」（6.8）と同一の概念を用いるが、  
ここでは「解析 1 回分を ProposalSet として束ねる」という粒度を明示した。

### 17.5 適用履歴（ApplyHistory）

**用途：**  
解析で得られた改善提案セットのうち「どの提案を、どのタイミングで、どの Terraform バージョンに対して適用したか」を管理する。

**主な項目（概念）：**

- 適用履歴 ID（`applyId`）
- 対象プロジェクト ID
- 対象解析 ID（`analysisId`）
- 対象提案セット ID（`proposalSetId`）
- 適用した提案 ID の一覧（`appliedProposalIds[]`）
- 適用元 Terraform バージョン（`terraformVersionBefore`）
- 適用後 Terraform バージョン（`terraformVersionAfter`）
- 適用実行日時（`appliedAt`）
- 実行者（ユーザー ID 等）
- 適用種別（手動適用／自動適用 等）
- 適用時のメモ（任意）

**例：**

- v1 解析で 10 件の提案が生成される
- そのうち 2 件を適用して Terraform `v1 → v2` へ更新
- さらに別の 3 件を適用して `v2 → v3` へ更新

といった履歴を、`ApplyHistory` の複数レコードとして表現する。

### 17.6 Terraform バージョンとの関係

Terraform バージョンの管理は Rinstack 本体の IaC 機能側の責務だが、  
FinOps 側は「どの Terraform バージョンに対してどの提案を適用したか」を参照・記録する。

- Terraform バージョン ID（例：`tf_v1`, `tf_v2`）は IaC 側で採番
- FinOps 側では `terraformVersionBefore` / `terraformVersionAfter` として文字列で保持
- 将来的に Terraform バージョン詳細とジョインして表示を高度化する余地を残す

### 17.7 UI と履歴モデルの関係（概念）

- **コスト運用ダッシュボード：**
  - 基本的には最新の解析履歴に紐づく集計と KPI を表示

- **コスト最適化管理画面：**
  - 特定の解析履歴（`analysisId`）を選択し、その解析で生成された提案一覧（`ProposalSet`）を表示

- **コスト最適化詳細画面：**
  - 単一提案の before / after 構成・コスト・リスクを表示
  - 「この提案を適用して Terraform を更新する」操作を将来的に提供しうる

これらの画面と、本書で定義した `AnalysisHistory` / `ProposalSet` / `ApplyHistory` の対応は、  
詳細設計書で 1:1 にマッピングすることを前提とする。

---

## 20. DB 選定とクエリ要件に関する補足

### 20.1 RDB / NoSQL の両立可能性

- 月次集計やサービス別コストはテーブル指向であり、RDB に向く。
- 改善案・解析履歴・適用履歴は JSON などのスキーマレスデータを含むため、NoSQL にも向く。

システム全体として、以下のパターンが考えられる：

- 単一の RDB に JSONB カラム等を用いて格納
- 集計系は RDB、履歴・提案系は NoSQL など、役割分担する

### 20.2 必須クエリ要件

DB 製品選定に先立ち、以下のクエリが安全に実行できることが必要条件となる。

- プロジェクト単位の月次コスト推移を期間指定で取得
- 特定サービスのコスト推移を期間指定で取得
- 最新の解析履歴（`analysisId`）を 1 件取得
- 特定解析の提案セット（`proposalSetId`）と、その中の提案一覧を取得
- 特定プロジェクトの適用履歴を期間指定で取得
- 特定適用履歴から、「どの提案を適用したか」「Terraform バージョンがどう遷移したか」を取得

DB 種別は本書では固定せず、  
これらクエリ要件を満たせる前提で、詳細設計にて選定する。

---

## Part D. API & UI Mapping（API 抽象＋UI 対応）

## 7. API 抽象設計（REST）

※ ここではエンドポイント名と返却データの概念のみを記載し、  
細かいスキーマは詳細設計で定義する。

### 7.1 コストサマリ取得 API（ダッシュボード上部 KPI 用）

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/cost/summary`

**入力：**

- プロジェクト ID
- 対象期間（例：年月）

**出力（概念）：**

- 当月コスト合計
- 当月予測コスト合計
- 前月同時期コスト
- 前月総コスト
- 施策により削減したコスト合計
- 実行した施策数
- 最適化提案数

### 7.2 サービス別コスト推移 API（棒グラフ用）

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/cost/service-monthly`

**入力：**

- プロジェクト ID
- 対象期間（開始月／終了月）

**出力（概念）：**

- 月ごとのサービス別コスト一覧（例：月・サービス名・金額のリスト）

### 7.3 コスト履歴テーブル API

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/cost/history`

**入力：**

- プロジェクト ID
- 対象期間（開始月／終了月）
- ページ番号
- 1 ページあたりの件数

**出力（概念）：**

- サービスごとの月別コスト（テーブル用）
- 合計行の情報
- ページング情報（全件数 / 現在ページ 等）

### 7.4 改善提案一覧 API

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/advices`

**入力：**

- プロジェクト ID
- 解析 ID（任意。指定しない場合は最新解析を返すなどのポリシーを詳細設計で決定）
- フィルタ条件（重要度／ステータス／期間 等）
- ページング情報

**出力（概念）：**

- 改善案の一覧（コード・タイトル・サービス名・重要度・ステータス 等）
- ページング情報

### 7.5 改善提案セット／解析履歴 API

#### 7.5.1 解析履歴一覧 API

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/analyses`

**入力：**

- プロジェクト ID
- 期間フィルタ（任意）

**出力：**

- 解析履歴（`analysis_id`, 実行日時, 対象期間, 提案件数 等）の一覧

#### 7.5.2 解析詳細 API

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/analyses/{analysisId}`

**出力：**

- 解析履歴の詳細
- 対応する改善提案セット ID
- 改善案一覧の要約 等

### 7.6 適用履歴 API

- HTTP メソッド：`GET`
- パス例：`/finops/projects/{projectId}/applies`

**入力：**

- プロジェクト ID
- 期間
- 関連する解析 ID（任意）

**出力：**

- 適用履歴（`apply_id`, 使用した提案一覧, `tf_version_before` / `tf_version_after`, 実行者, 実行日時 等）

---

## 11. UI（Figma）との対応づけ（概念）

`FinOps_Figma.zip` には、以下の画面が含まれる。

- コスト運用ダッシュボード（Figma 1 枚目）
- コスト最適化管理（Figma 2 枚目）
- コスト最適化詳細画面（Figma 3 枚目）

本書で定義したデータモデルおよび API は、これらの画面と以下のように対応する。

### 11.1 コスト運用ダッシュボード

- 上部 KPI：月次コスト集計 / 施策実績 / 改善案数
- 棒グラフ・履歴テーブル：サービス別 × 月別コスト集計（6.4）

### 11.2 コスト最適化管理画面

- 改善案一覧（CSG000001…）：
  - 改善案モデル
  - 改善提案セット・解析履歴との関係

### 11.3 コスト最適化詳細画面

- 現在構成／推奨構成の比較表：
  - 改善案モデルの構造化提案
- リスク評価：
  - LLM 生成のリスク情報
- 「1 件の提案を適用」ボタン：
  - 適用履歴
  - 将来の Terraform 連携のトリガー

UI とバックエンドの対応は、詳細設計書にて  
画面項目 vs API vs データモデル の 1:1 のマッピング表として整理する。

---

## Part E. Integration with Rinstack（Rinstack 固有の前提・境界）

## 8. Terraform / GitHub 連携との境界

### 8.1 FinOps の責務

- 既存 クラウドプロバイダー 環境のコスト可視化
- LLM による改善案生成（提案セット）
- 解析履歴の保持
- 改善案と Terraform バージョンのひも付け
- 適用履歴の保持

### 8.2 Rinstack 本体（IaC 機能）の責務

- Terraform の生成・バージョン管理
- GitHub 連携（リポジトリ・ブランチ・PR）
- FinOps から渡された「どの提案を採用するか」という情報を元に、Terraform 差分生成／PR 作成を行う（将来機能）

本基本設計では、Terraform 連携については  
「FinOps 側の構造化情報を IaC 側が利用可能にしておく」という前提のみを示し、  
実際の IaC 反映処理は別設計とする。

---

## 13. Rinstack との認証・認可

FinOps サービスは、`rinstack-app` の JWT 検証結果を前提としている。

JWT に含まれるクレーム（`organizationId` / `projectId` / `userId` 等）のうち、  
FinOps が必要とするのは主に `organizationId` と `projectId`、ログ用に `userId` である。

トークンの有効期限・更新戦略は、既存 `rinstack-app` の設計方針に従う。

---

## 追加補足（Rinstack 固有情報の継承）

以下は、本書に統合すべき Rinstack 固有の前提情報である。

### 1. TMP（課金レポート中間管理モデル）の明示的継承

Rinstack FinOps では課金レポートファイルの処理状態を管理する内部モデルとして  
TMP（Temporary 課金レポート Management Point）を利用する慣習があった。

本書では名称が「課金レポートファイル管理」に統一されたが、  
Rinstack の実装コンテキストを継承するため、TMP は以下のように扱う：

- 「課金レポートファイル管理」は TMP の後継にあたる
- ステータス管理（未処理／処理中／完了／失敗）は、本書の定義に従う。
- LLM バッチ・課金レポートバッチが TMP を参照するという思想を本書に統合

### 2. Rinstack の `service-auth.middleware` による JWT 検証仕様

Rinstack では backend（`rinstack-app`）側に `service-auth.middleware` が存在し、  
service-to-service JWT の検証責務を持つ。

本書の前提として以下を明示する：

- FinOps → Rinstack への API 呼び出しは `service-auth.middleware` を通過する
- `client_id = "finops-service"` を利用する
- JWT のクレーム検証は Rinstack 既存仕様に従う
- `organizationId` / `projectId` は `rinstack-app` が正規化した値を FinOps が受け取る

### 3. `rinstack-web` の `projectId` 固定 UI スコープ

Rinstack は UI（`rinstack-web`）がプロジェクト単位で完全に分離されている。

- 全ての FinOps 画面は `projectId` を URL に含む
- `projectId` は Vue / Nuxt のルーティング階層に必須

そのため FinOps DB の全データは `projectId` を partition key として保持することが前提。

本書では、UI のプロジェクトスコープを前提として  
API・DB モデルの `projectId` 必須性を明文化する。

---

## 追加統合事項（Rinstack 固有前提の補完）

1. TMP と 課金レポート取得バッチ（バッチ A）の関係  
   TMP は課金レポート取得バッチにおける中間管理モデルであり、  
   課金レポートファイル検出・処理状態管理の基盤となる。  
   本書では課金レポートファイル管理として再編したが、その役割は継承される。

2. NoSQL 推奨の背景  
   FinOps データ（改善案・解析履歴・適用履歴）はスキーマレス構造を含むため、NoSQL と親和性が高い。  
   月次集計も NoSQL で運用可能であるが、最終選定は詳細設計で行う。

3. 課金レポート → LLM の二段階モデル  
   FinOps 処理は「課金レポート取得（バッチ A）→ 集計 → LLM 解析（バッチ B）」の二段階構造であり、  
   解析負荷と責務境界を明確化する。

4. UI の補足要件  
   UI には割合表示、効果度合い（高 / 中 / 低）、作業量（軽微 / 中 / 重度）の概念が存在し、  
   改善案モデルで保持可能である。

5. 施策実績モデルを独立させる理由  
   改善案にステータスのみを持たせると、複数回適用や部分適用時に破綻するため、  
   施策実績は適用履歴と独立した概念として保持する。

6. NoSQL 向けキー設計の指針  
   `projectId` をパーティションキー、月や解析 ID をソートキーとし、  
   必要に応じて GSI を利用する構成が適する。

7. 課金レポート解析のストリーミング処理  
   課金レポートの行数増加に備え、ストリーミング処理・分割処理・並列度制御が望ましい。

8. Figma と API の 1:1 マッピング  
   画面要素・API・データモデルの 1:1 マッピング表は詳細設計で必ず作成する。

---

## Part F. Non-functional & Detailed Decisions Later（非機能・詳細設計で決めること）

## 9. 非機能要件

### 9.1 セキュリティ

- クラウドプロバイダー認証情報は必ず暗号化保存し、ログ出力しない。
- S2S JWT にはクライアント ID と有効期限を持たせる。
- FinOps DB へのアクセスは、`rinstack-app` からの経路に限定する。

### 9.2 性能

- 課金レポートの行数増加を想定し、課金レポート → 集計 → 保存の処理をストリーミングやバッチで制御する。
- 解析履歴・適用履歴が増加しても、主要 API（ダッシュボード表示）が一定時間内に応答できるようインデックス設計を行う。

### 9.3 可用性

- 解析処理の失敗はステータス管理し、手動／自動で再実行可能とする（詳細は運用設計）。
- FinOps DB 障害時にも、最低限の過去データが復元できるバックアップポリシーを別途定義する。

### 9.4 キャッシュ

FinOps ダッシュボードの即時応答性向上のためキャッシュ利用を検討する。  
採用は詳細設計で決定する。

- 候補: メモリキャッシュ / Redis / マテリアライズドビュー
- 対象: 月次集計 / サービス別内訳 / 改善案一覧・詳細
- 解析完了時に更新またはクリア。
- TTL の目安: 30〜300 秒。

---

## 10. 詳細設計で決めるべき事項

本書では FinOps 機能の全体構成とデータモデルを定義しているが、  
以下の事項については詳細設計フェーズで最終決定する。

### クラウドプロバイダー / セキュリティまわり

- クラウドプロバイダー 側 クラウド側の認可ロール設計（権限範囲・信頼ポリシー・ExternalID の扱い）
- FinOps 用ロールとデプロイ用ロールの分離方針（ロール引き受け方式先の整理）

### データベース / ストレージ

- FinOps DB の具体的な製品／サービス（RDB / NoSQL）
- 各コレクション（テーブル）の主キー・セカンダリインデックス設計
- 大量課金レポートデータを扱う際のストレージ戦略（パーティション設計・アーカイブ方針 等）

### 課金レポート取得・解析方式

- 課金レポートの取り込み方式（CSV / Parquet / Athena 経由 等）
- 課金レポートパース処理の実装方式（ストリーミング処理／一括ロード）
- 大規模環境でのバッチ分割戦略（プロジェクト単位・月単位など）

### LLM 利用方針

- LLM モデル種別（利用するプロバイダ・モデル名）
- プロンプト設計（入力テンプレート・出力 JSON の期待構造）
- 1 回の解析あたりの提案件数・トークン上限
- LLM 解析ジョブのリトライポリシー（タイムアウト・エラー時の扱い）

### KPI / コスト計算ロジック

- コスト予測ロジック（当月予測コストの算出方法）
- KPI の最終定義（ビジネス指標としての意味付け・どの解析履歴を基準とするか）
- 削減額・削減率の算出ロジック（実績値ベースか、推定値ベースか）

### 画面仕様・API I/O

- Figma 3 画面に対応する画面仕様・API 詳細
  - ダッシュボード（KPI・グラフ・テーブル）の I/O
  - コスト最適化管理画面（一覧・フィルタ・ページング）の I/O
  - コスト最適化詳細画面（構成差分・リスク表示・適用操作）の I/O
- API のエラーレスポンス仕様・バリデーションポリシー

### 解析トリガーと運用

- 解析トリガー（オンデマンド／バッチ）の最終ポリシー
- 解析実行中の同時実行制御（ロック方式・キューイング方針）
- 解析履歴・適用履歴の保持期間およびアーカイブポリシー

### 状態管理・IaC 連携

- 改善提案のステータス遷移（未対応／対応中／対応済み 等）の状態遷移ルール
- Terraform バージョン情報との連携方式（IaC 側 API / DB とどの粒度でひも付けるか）
- 適用履歴から Terraform 差分生成までのインターフェース（将来機能を見据えた前提定義）

---

## 14. メタメモ：前提条件と設計上の判断材料

本節は、本書を作成するにあたっての前提条件・判断材料を記録するものであり、実装仕様ではない。

### 14.1 KPI 定義の暫定性

ダッシュボードの KPI は Figma 上の UI イメージをもとに設計されているが、  
ビジネスとしてどの指標を重視するかは今後の議論が必要である。

本書では「一般的な FinOps 文脈で自然な定義」を暫定採用し、  
将来ビジネス要件に応じて再調整される可能性を明示する。

### 14.2 バッチ vs オンデマンド

- 日次バッチのみで運用した場合、解析履歴が過度に増加し、  
  ユーザーから見て「どの解析に基づく提案か」が分かりにくくなる。
- Terraform のバージョン管理と組み合わせる場合、  
  「ユーザーが意図したタイミングで解析を実行し、その結果に対して提案を適用する」  
  というフローが自然であるため、オンデマンド方式を主とした。

### 14.3 LLM の責務境界

LLM は、あくまで「文章」「推奨構成候補」「リスクコメント」の生成に集中させる。

- コスト計算・構造化 JSON の整形・ID 付与などは FinOps サービス側で行う。
- 将来的に UI バリエーションが増えた場合、LLM から HTML 断片（iframe 埋め込み用）を生成する可能性もあるが、  
  本書時点では「構造化 JSON をベースとした情報提供」を主とする。

### 14.4 DB 選定について

- 月次集計やサービス別コストはテーブル指向であり RDB に向く。
- 改善案や解析履歴・適用履歴はスキーマレスな JSON を含むため、NoSQL にも向く。

本書では特定の製品（例：PostgreSQL / DynamoDB）には依存しない。  
将来のデータ量・運用要件を踏まえ、詳細設計で選定する。

### 14.5 クラウド側の認可ロールの拡張性

現時点ではストレージ読み取りのみを前提とした最小権限設計とするが、  
長期的には Terraform デプロイ・アプリケーションデプロイを含む構想がある。

そのため、FinOps 用ロールとデプロイ用ロールを分離する前提を基本設計段階で明示した。

### 14.6 Rinstack 全体構想との整合性

Rinstack は「IaC 管理＋LLM 生成＋GitHub 連携＋デプロイまで」をカバーする長期構想を持つ。

FinOps は、その中で「既存環境のコスト最適化」という縦の機能を担い、  
Terraform / GitHub との接点を「構造化された改善案」「適用履歴」を通じて提供する役割を持つ。

---

## Part G. Cloud Provider Scope（クラウドプロバイダ別スコープ）

### 0.1 フェーズ 1：初期スコープ（AWS）

本節では、初期スコープとして想定するクラウド環境（AWS）に固有の仕様・制約・接続方式・課金データ取得方法など、  
クラウド非依存の抽象モデルに含めるべきではない情報をまとめて扱う。

現時点では、本書の本文側からは「クラウド非依存で表現できない項目」を切り出し、  
この節に集約する方針のみを示し、具体的な記述は Ver26 以降で移動・整理する。

#### 0.1.1 初期スコープ専用：AWS 固有情報（概要）

- AssumeRole 等を前提とした接続方式
- IAM ロール構造および信頼ポリシーの詳細
- S3 / CUR など、課金データ取得に関する AWS 固有仕様
- AWS 特有のメトリクス・KPI 計算ロジックの補足
- その他、マルチクラウド抽象モデルに持ち込まない方がよい AWS 固有の前提

#### 0.1.2 初期スコープ専用：AWS 固有情報（抽象化困難な項目）

この小節には、FinOps の抽象モデルには含めず、  
初期スコープ（AWS）向けの詳細設計や実装検討でのみ参照することを前提とした情報を集約する。

##### 0.1.2.1 本文から切り出したクラウドプロバイダー固有記述（初期スコープ用メモ）

本節には、FinOps 全体の抽象モデルから切り出したクラウドプロバイダー固有の記述をメモとして保持する。  
これらは主に初期スコープ（特定クラウド環境）での詳細設計や実装検討時に利用されることを想定する。

- 初期スコープでは AWS AssumeRole による接続方式を採用する（抽象モデルはクラウド横断）
- AWS 接続方式（AssumeRole ベース）
- CUR 取得 → 集計 → LLM 解析 → 履歴保存の処理フロー
- AWS IAM Role の権限範囲・信頼ポリシー
- CUR パースロジック（CSV / Parquet / Athena）
- 対象クラウド：AWS（将来マルチクラウド対応を検討）
- AWS との連携方式（ロールフェデレーション方式の概要）
- 処理構成（CUR 取得／解析実行トリガー／LLM 解析）
- ユーザーが既に保有している AWS 環境に対して：
  - AWS CUR（Cost & Usage Report）を S3 から取得
- マルチクラウド（GCP / Azure / OCI 等）の実装（将来拡張）
- CUR 取得および解析を行う処理（バッチ／オンデマンド）
- AWS：AssumeRole 相当
- GCP：Workload Identity Federation
- Azure：Federated Credential
- OCI：Dynamic Group ベース
- さくらクラウド：固定鍵方式寄り（将来拡張余地あり）

**CUR ファイル関連：**

- 1 CUR ファイル取得
- CUR ファイル取得処理（CUR 取得）の目的：S3 上の CUR ファイルを列挙し、処理対象として管理する。
  - プロジェクトごとの AWS 接続設定
  - 対象プロジェクトの S3 バケット／プレフィックスを取得
  - S3 上の CUR ファイル一覧を取得
  - まだ処理していないファイルのみを「CUR ファイル管理」コレクションに
    - S3 キー
    - CUR 期間（例：2025-11）として登録

**解析関連：**

- 解析（CUR → 集計 → LLM 提案）は、以下二つの方式が候補となる。
- 目的：CUR 集計結果からコスト改善案を生成し、解析履歴・改善案として保存する。
- 対象とする CUR 期間（例：2025-11）
  1. 「CUR ファイル管理」から対象期間のファイルを特定
  2. CUR ファイルを読み込み、明細レコードを解析
- CUR のパースや数値集計は FinOps サービス側の決定的ロジックとする。

**AWS 接続設定：**

- 用途：各プロジェクトがどの AWS 環境に対して CUR を取得するかを管理する。
  - 接続方式（AssumeRole 固定、将来 AccessKey 等の拡張もあり得る）
  - AWS アカウント ID
  - S3 バケット名
  - S3 プレフィックス

**CUR ファイル管理：**

- 用途：CUR ファイルごとの処理状態を管理する。
  - CUR ファイル ID
  - S3 キー（パス）
  - CUR 対象期間（例：2025-11）

**解析履歴：**

- 用途：CUR 解析結果および LLM 改善提案の「スナップショット」を保持する。
- 解析履歴は「どのタイミングで、どのデータ（CUR）を元に、どの改善提案セットが生成されたか」を表現する。
- 対象 CUR 期間（例：2025-11）
- 対象サービス名（例：RDS, ECS）

**セキュリティ・パフォーマンス関連：**

- 既存 AWS 環境のコスト可視化
- AWS 認証情報は必ず暗号化保存し、ログ出力しない。
- CUR の行数増加を想定し、CUR → 集計 → 保存の処理をストリーミングやバッチで制御する。

**AWS / セキュリティまわり：**

- AWS 側 IAM Role 設計（権限範囲・信頼ポリシー・ExternalID の扱い）
- FinOps 用ロールとデプロイ用ロールの分離方針（AssumeRole 先の整理）
- 大量 CUR データを扱う際のストレージ戦略（パーティション設計・アーカイブ方針 等）

**CUR 取得・解析方式：**

- CUR の取り込み方式（CSV / Parquet / Athena 経由 等）
- CUR パース処理の実装方式（ストリーミング処理／一括ロード）
- CUR 取得はバッチ／オンデマンドのいずれも可能だが、MVP ではオンデマンド解析を主とする。
- 解析結果が存在しない場合の振る舞い（例：空表示／CUR からの自動集計）は、UX と相談の上詳細設計で決定する。

**IAM ロールの拡張性：**

- 現時点では S3 読み取りのみを前提とした最小権限設計とするが、  
  AWS CUR 関連ドキュメント・AWS 仕様・AWS CUR 仕様（Billing CSV / Parquet）を踏まえ拡張の余地を残す。

**CUR → LLM 解析：**

- CUR から LLM によるコスト改善提案を生成する処理は、将来的に複数回実行されることを前提とする。
- 「どの CUR / Terraform 状態に対して」
- 解析対象の CUR 情報
- 対象とした CUR ファイルの一覧
- CUR 集計結果に基づく数値的なコスト計算（現状／推奨／削減額／削減率）
- CUR → LLM 解析を日次バッチ等で自動実行する場合の課題も、課金レポート版と同様に存在する。

---

## 21. FinOps における IAM 権限スコープに関する補足

### 21.1 FinOps MVP における最小権限

課金レポート取得に必要なストレージ読み取り権限のみを付与する。

- `s3:ListBucket`
- `s3:GetObject`
- STS によるロール引き受け権限：
  - `sts:ロール引き受け方式`

それ以外のリソース操作（コンピュートリソース, マネージドデータベース, コンテナ実行環境 等）は  
FinOps ロールのスコープ外とする。

### 21.2 長期ロードマップとの関係

Rinstack 全体のロードマップとしては、

- Terraform による環境構築
- アプリケーションのデプロイ

など、より広範な クラウドプロバイダー リソース操作が想定されている。  
これに伴い、将来的には

- Rinstack Deploy 用 クラウド側の認可ロール（コンピュートリソース / コンテナ実行環境 / マネージドデータベース 等含む）
- FinOps 専用 クラウド側の認可ロール（課金レポート参照専用）

といった **ロール分離** を行う前提とする。

本書では、FinOps は「課金レポート読み取り専用」のロールのみを前提とし、  
その他の権限は Rinstack 本体の別機能で扱うものとする。

---

## Part H. LLM Policy（LLM の責務・出力形式）

## 18. LLM の責務範囲と出力形式に関する前提

本章では、LLM にどこまでを任せ、FinOps サービス側でどこまでを決定的ロジックとして実装するか、  
本書時点での前提を整理する。

### 18.1 LLM の責務

LLM は以下の出力を担うものとする。

- コスト改善提案の「自然言語による説明」
- 推奨構成の候補（例：インスタンスタイプ、vCPU / メモリ構成など）の案
- リスク評価コメント（性能リスク・可用性リスク・スパイク時挙動など）

一方で、以下は FinOps サービス側の責務とする。

- 課金レポート集計結果に基づく数値的なコスト計算（現状／推奨／削減額／削減率）
- JSON 構造（構造化提案）の最終整形
- 提案 ID・セット ID などの採番
- Terraform バージョンとの紐付け（どのバージョンに対する提案か）

### 18.2 出力形式の柔軟性（JSON / HTML 等）

基本方針として、LLM の主な出力形式は「構造化 JSON」とする。

例：

```json
{
  "title": "...",
  "description": "...",
  "currentConfig": {...},
  "recommendedConfig": {...},
  "risks": [...]
}
```

UI バリエーションが増えた場合、

- カード UI
- 表形式
- テキスト中心のレポート形式

など複数の表現方法が考えられる。

その際、

- JSON を基準とした構造化データは常に保持し、
- 場合によっては、提案詳細画面に埋め込む HTML 断片（カード UI 等）を LLM に生成させる可能性がある。

その際も、永続化される一次データは **JSON ベースの構造化データ** とし、  
HTML は「表示レイヤ用キャッシュ」あるいは「ビュー用テンプレート」として扱う。

本書では、JSON を主たる永続フォーマットとし、  
HTML 等のフォーマットは「将来の拡張候補」であることのみをメタメモとして残す。

---

## Part I. References（参照元・参照必須資料）

## 15. 本基本設計書の参照元

本書は以下の資料を基に作成した。

### 内部実装リポジトリ

- `rinstack-app`（バックエンド実装）
- `rinstack-web`（フロントエンド実装）

### UI 仕様（Figma）

- `FinOps_Figma.zip`
  - コスト運用画面（プロジェクト別で独立）.png
  - コスト最適化管理画面（プロジェクト別で独立）.png
  - コスト最適化詳細画面（コスト最適化画面の詳細押下時に遷移）.png

### PM 提供資料

- コスト改善のデータ構造イメージ（スプレッドシート）

### 外部参考資料

- クラウドプロバイダー 課金レポート関連ドキュメント  
  - https://qiita.com/kazuki_horiuchi/items/d197c3edfdb7b49aa4d6
  - https://newrelic.com/jp/blog/how-to-relic/aws-cur-visualise

---

## 16. 今後の詳細設計書作成時に必ず参照すべき資料

詳細設計を行う際に必ず参照すべき資料は以下の通りである。

### 内部実装リポジトリ

- `rinstack-app`（バックエンド実装）
- `rinstack-web`（フロントエンド実装）

### UI 仕様（Figma・ファイル名込み）

- `FinOps_Figma.zip`
  - コスト運用画面（プロジェクト別で独立）.png
  - コスト最適化管理画面（プロジェクト別で独立）.png
  - コスト最適化詳細画面（コスト最適化画面の詳細押下時に遷移）.png

### PM 提供資料

- コスト改善のデータ構造イメージ（スプレッドシート）

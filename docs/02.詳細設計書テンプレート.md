##### 詳細設計テンプレート（バックエンド用 / AI駆動開発 - Cursor）

> 別のLLMが README とこの設計書だけを読めば同じ機能を再実装できるレベルで記述すること。  
> エラーハンドリングは国際化対応が前提（HTTPステータス + errorCode、message非表示）

#### 機能名
この機能が何を指すのかを端的に表現する名称（例：ユーザー招待）

#### 実行トリガー
この機能が実行される契機（UI操作 / バッチ起動 / 外部Webhook など）

#### 機能の目的・背景
なぜこの機能が必要なのか？どのようなユースケース／ユーザー要求に応えるのか？

#### 業務的な前提・制約
この機能が前提とする業務上のルールやドメイン固有の制約

#### 外部とのインターフェース
- 使用APIエンドポイント（Swaggerに記載されていることを前提）
- 依存する外部サービス、Webhook、通知メールなど
- 副作用（通知、WebHook、Audit Log など）

#### 内部データ構造・状態
- 主に扱うデータモデル・テーブル
- ステータス／フラグ／トークンの仕様と意味

#### 状態遷移（任意: Mermaid形式）
```
stateDiagram-v2
  [*] --> 初期状態
  初期状態 --> 招待中 : 招待送信
  招待中 --> 有効化待ち : メール確認済み
  有効化待ち --> 有効 : 登録完了
  有効 --> [*]
```

#### 権限・認可
- この機能を実行するために必要な認可条件（role, authorityStatusCode）
- チェック場所（例：service.tsの関数冒頭）
- 判定方式（shared/auth/permission.ts 参照）

#### レスポンス仕様（Zod + infer前提）
- ステータスコード: `200 OK`, `201 Created`, etc.
- 型定義:
  ```ts
  const InviteResponseSchema = z.object({
    inviteId: z.string(),
    status: z.enum(["invited", "accepted", "expired"]),
    expiresAt: z.string(), // ISO8601
  });
  ```
  - スキーマ定義は schema.ts に集約し、`.infer<typeof InviteResponseSchema>`で型を使用

#### エラー・例外処理（国際化エラーコード対応）
- HTTPステータス + `errorCode` をセットで返す（Upper_Snake_Case）
- `message` はログ用途（UIでは使用しない）
- フロント側でエラーメッセージは `errorCode` によって静的にマッピング
- 例：
  ```json
  HTTP/1.1 403 Forbidden
  {
    "errorCode": "FORBIDDEN"
  }
  ```

#### ファイル構成（責務分離）
- `routes.ts`: HTTPルーティング、Zodバリデーション
- `schema.ts`: 入出力スキーマの定義
- `service.ts`: ユースケース実装、権限チェック、業務ロジック
- `repository.ts`: DBアクセス層
- `email.ts`: EJSテンプレート通知（必要に応じて）

#### 保存すべきログ（任意）
どの操作が、いつ、誰によって実行されたか追跡すべき場合に記載

#### READMEからの逸脱ポイント  
READMEに定義された構成・責務分離・設計方針に対し、  
この機能が意図的に逸脱している点があれば、明確に列挙すること。  
逸脱が無い場合は「なし」と明記する。
